## 进程

**进程：** 程序（代码）在资源集合上的运行一次运行过程

代码+{PCB+I/O设备+内存+cpu}=>进程的内存映像

或者这么理解，逻辑内存随着时间映射到不同的物理内存
$$
PA=f(LA,t)
$$

### PCB：

- Running队列->PCB
- Ready->PCB

### I/O设备：

| 逻辑设备号 | 物理设备号 |
| ---------- | ---------- |
| 1          | &xxx       |
| 2          | ...        |
| ...        | ...        |

### 内存（elf表）：

| LA   | PA   |
| ---- | ---- |
| 1    | ？   |
| 2    | ？   |
| ...  | .... |

### cpu（寄存器快照）



## 系统内存

- PCB队列
- 系统缓冲
- IPC机制
  - 管道
  - 信号

| 线性地址  | 区域                     |
| --------- | ------------------------ |
| FFFFFFFFH | SYSTEM系统运行的全局信息 |
|           | stack、so库              |
|           | heap、bss、DATA          |
| 08048000H | TEXT                     |
| 00000000H | 起始                     |

## 线程

将同一任务划分为可并行逻辑子任务，从而可充分利用cpu多核环境，由于子任务存在亲缘性，所以他们共享许多资源，在子任务进行切换时仅仅保存极少量的断点信息

- 子任务->轻载进程
- 在内核支持多线程的系统中，进程是资源集合
- 线程是计算任务分配单元
- 在编程时，必须进行逻辑任务划分
- 实现：
  - 内核级线程（Windows由内核进行调度）
    - 由于内核支持多线程，所以当其中一个线程阻塞是可切换另一线程进行不会引发进程切换
  - 用户级线程库（以linux为例）
    - 每次线程切换，均会引起访管中断
    - 由于内核仅支持单线程进程，当任何一个线程发生阻塞时，均会引起进程切换

命令行：

```shell
ps aux  显示详细经常信息
ps aux|grep test 在列表中查询test信息
kill -SIGSTOP 进程号   杀死进程
```

### 僵尸进程

**父在子先亡**：正常结束，不产生僵尸进程

**反之**：资源无法释放，产生僵尸进程（孤儿进程）

**解决方法**：所有孤儿进程均由1号进程进行回收

#### 守护进程（精灵进程）：

是孤儿进程的特例：

1. 主动杀死父进程
2. 主动清除了从父进程中继承的资源

目的：

- 为了在启动由1号进程管理
- 进行系统任务
- 无需人机交互

### 管理进程的总数据结构

**PCB**：进程打开文件列表，内存地址映射表，cpu快照

1. 表格实现装配，编程仅需使用逻辑号（设备号、文件描述符、线性地址）
2. 扩展逻辑地址的方式——简介索引（多级指针）
3. 用户编程时，仅能自由使用ELF表中从data段开始至stack段结束的线性地址
4. 其中text段地址为只读，高1G地址留给os使用